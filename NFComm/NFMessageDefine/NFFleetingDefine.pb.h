// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NFFleetingDefine.proto

#ifndef PROTOBUF_NFFleetingDefine_2eproto__INCLUDED
#define PROTOBUF_NFFleetingDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace NFFS {

// Internal implementation detail -- do not call these.
void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
void protobuf_AssignDesc_NFFleetingDefine_2eproto();
void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

class FSVector3;
class FixTimeEvent;
class FixTimeEvent_EventTrigger;
class FixTimeEvent_HitTrigger;
class BulletEvent;
class BulletEvent_TacheBomp;
class BulletEvent_Bullet;
class AudioEvent;
class AudioEvent_Audio;
class MoveEvent;
class MoveEvent_Move;
class CameraEvent;
class CameraEvent_Camera;
class EnableEvents;
class EnableEvents_Enable;
class GlobalSpeed;
class GlobalSpeed_Speed;

enum BulletEvent_EBEType {
  BulletEvent_EBEType_ESET_TARGET = 0,
  BulletEvent_EBEType_ESET_POSITION = 1
};
LIBPROTOC_EXPORT bool BulletEvent_EBEType_IsValid(int value);
const BulletEvent_EBEType BulletEvent_EBEType_EBEType_MIN = BulletEvent_EBEType_ESET_TARGET;
const BulletEvent_EBEType BulletEvent_EBEType_EBEType_MAX = BulletEvent_EBEType_ESET_POSITION;
const int BulletEvent_EBEType_EBEType_ARRAYSIZE = BulletEvent_EBEType_EBEType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* BulletEvent_EBEType_descriptor();
inline const ::std::string& BulletEvent_EBEType_Name(BulletEvent_EBEType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BulletEvent_EBEType_descriptor(), value);
}
inline bool BulletEvent_EBEType_Parse(
    const ::std::string& name, BulletEvent_EBEType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BulletEvent_EBEType>(
    BulletEvent_EBEType_descriptor(), name, value);
}
enum BulletEvent_EBE_BACKType {
  BulletEvent_EBE_BACKType_EBEBT_BACK = 0,
  BulletEvent_EBE_BACKType_EBEBT_SIDE = 1
};
LIBPROTOC_EXPORT bool BulletEvent_EBE_BACKType_IsValid(int value);
const BulletEvent_EBE_BACKType BulletEvent_EBE_BACKType_EBE_BACKType_MIN = BulletEvent_EBE_BACKType_EBEBT_BACK;
const BulletEvent_EBE_BACKType BulletEvent_EBE_BACKType_EBE_BACKType_MAX = BulletEvent_EBE_BACKType_EBEBT_SIDE;
const int BulletEvent_EBE_BACKType_EBE_BACKType_ARRAYSIZE = BulletEvent_EBE_BACKType_EBE_BACKType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* BulletEvent_EBE_BACKType_descriptor();
inline const ::std::string& BulletEvent_EBE_BACKType_Name(BulletEvent_EBE_BACKType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BulletEvent_EBE_BACKType_descriptor(), value);
}
inline bool BulletEvent_EBE_BACKType_Parse(
    const ::std::string& name, BulletEvent_EBE_BACKType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BulletEvent_EBE_BACKType>(
    BulletEvent_EBE_BACKType_descriptor(), name, value);
}
enum MoveEvent_METype {
  MoveEvent_METype_ME_FORWARD = 0,
  MoveEvent_METype_ME_BACK = 1,
  MoveEvent_METype_ME_LEFT = 2,
  MoveEvent_METype_ME_RIGHT = 3
};
LIBPROTOC_EXPORT bool MoveEvent_METype_IsValid(int value);
const MoveEvent_METype MoveEvent_METype_METype_MIN = MoveEvent_METype_ME_FORWARD;
const MoveEvent_METype MoveEvent_METype_METype_MAX = MoveEvent_METype_ME_RIGHT;
const int MoveEvent_METype_METype_ARRAYSIZE = MoveEvent_METype_METype_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* MoveEvent_METype_descriptor();
inline const ::std::string& MoveEvent_METype_Name(MoveEvent_METype value) {
  return ::google::protobuf::internal::NameOfEnum(
    MoveEvent_METype_descriptor(), value);
}
inline bool MoveEvent_METype_Parse(
    const ::std::string& name, MoveEvent_METype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MoveEvent_METype>(
    MoveEvent_METype_descriptor(), name, value);
}
enum CameraEvent_CEType {
  CameraEvent_CEType_Earthquake = 0,
  CameraEvent_CEType_Explosion = 1,
  CameraEvent_CEType_No = 2,
  CameraEvent_CEType_FireKick = 3,
  CameraEvent_CEType_Stomp = 4,
  CameraEvent_CEType_Yes = 5,
  CameraEvent_CEType_SprintShake = 6,
  CameraEvent_CEType_FreeMode = 7,
  CameraEvent_CEType_MainRPGMode = 8
};
LIBPROTOC_EXPORT bool CameraEvent_CEType_IsValid(int value);
const CameraEvent_CEType CameraEvent_CEType_CEType_MIN = CameraEvent_CEType_Earthquake;
const CameraEvent_CEType CameraEvent_CEType_CEType_MAX = CameraEvent_CEType_MainRPGMode;
const int CameraEvent_CEType_CEType_ARRAYSIZE = CameraEvent_CEType_CEType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* CameraEvent_CEType_descriptor();
inline const ::std::string& CameraEvent_CEType_Name(CameraEvent_CEType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CameraEvent_CEType_descriptor(), value);
}
inline bool CameraEvent_CEType_Parse(
    const ::std::string& name, CameraEvent_CEType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraEvent_CEType>(
    CameraEvent_CEType_descriptor(), name, value);
}
enum EnableEvents_EEETYPE {
  EnableEvents_EEETYPE_INIT = 0,
  EnableEvents_EEETYPE_FINAL = 1
};
LIBPROTOC_EXPORT bool EnableEvents_EEETYPE_IsValid(int value);
const EnableEvents_EEETYPE EnableEvents_EEETYPE_EEETYPE_MIN = EnableEvents_EEETYPE_INIT;
const EnableEvents_EEETYPE EnableEvents_EEETYPE_EEETYPE_MAX = EnableEvents_EEETYPE_FINAL;
const int EnableEvents_EEETYPE_EEETYPE_ARRAYSIZE = EnableEvents_EEETYPE_EEETYPE_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* EnableEvents_EEETYPE_descriptor();
inline const ::std::string& EnableEvents_EEETYPE_Name(EnableEvents_EEETYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnableEvents_EEETYPE_descriptor(), value);
}
inline bool EnableEvents_EEETYPE_Parse(
    const ::std::string& name, EnableEvents_EEETYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnableEvents_EEETYPE>(
    EnableEvents_EEETYPE_descriptor(), name, value);
}
enum GlobalSpeed_EGSTYPE {
  GlobalSpeed_EGSTYPE_INIT = 0,
  GlobalSpeed_EGSTYPE_FINAL = 1
};
LIBPROTOC_EXPORT bool GlobalSpeed_EGSTYPE_IsValid(int value);
const GlobalSpeed_EGSTYPE GlobalSpeed_EGSTYPE_EGSTYPE_MIN = GlobalSpeed_EGSTYPE_INIT;
const GlobalSpeed_EGSTYPE GlobalSpeed_EGSTYPE_EGSTYPE_MAX = GlobalSpeed_EGSTYPE_FINAL;
const int GlobalSpeed_EGSTYPE_EGSTYPE_ARRAYSIZE = GlobalSpeed_EGSTYPE_EGSTYPE_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* GlobalSpeed_EGSTYPE_descriptor();
inline const ::std::string& GlobalSpeed_EGSTYPE_Name(GlobalSpeed_EGSTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GlobalSpeed_EGSTYPE_descriptor(), value);
}
inline bool GlobalSpeed_EGSTYPE_Parse(
    const ::std::string& name, GlobalSpeed_EGSTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GlobalSpeed_EGSTYPE>(
    GlobalSpeed_EGSTYPE_descriptor(), name, value);
}
// ===================================================================

class LIBPROTOC_EXPORT FSVector3 : public ::google::protobuf::Message {
 public:
  FSVector3();
  virtual ~FSVector3();

  FSVector3(const FSVector3& from);

  inline FSVector3& operator=(const FSVector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FSVector3& default_instance();

  void Swap(FSVector3* other);

  // implements Message ----------------------------------------------

  FSVector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FSVector3& from);
  void MergeFrom(const FSVector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:NFFS.FSVector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static FSVector3* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT FixTimeEvent_EventTrigger : public ::google::protobuf::Message {
 public:
  FixTimeEvent_EventTrigger();
  virtual ~FixTimeEvent_EventTrigger();

  FixTimeEvent_EventTrigger(const FixTimeEvent_EventTrigger& from);

  inline FixTimeEvent_EventTrigger& operator=(const FixTimeEvent_EventTrigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FixTimeEvent_EventTrigger& default_instance();

  void Swap(FixTimeEvent_EventTrigger* other);

  // implements Message ----------------------------------------------

  FixTimeEvent_EventTrigger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FixTimeEvent_EventTrigger& from);
  void MergeFrom(const FixTimeEvent_EventTrigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float eventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.FSVector3 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline const ::NFFS::FSVector3& v() const;
  inline ::NFFS::FSVector3* mutable_v();
  inline ::NFFS::FSVector3* release_v();
  inline void set_allocated_v(::NFFS::FSVector3* v);

  // required string prefab = 3;
  inline bool has_prefab() const;
  inline void clear_prefab();
  static const int kPrefabFieldNumber = 3;
  inline const ::std::string& prefab() const;
  inline void set_prefab(const ::std::string& value);
  inline void set_prefab(const char* value);
  inline void set_prefab(const char* value, size_t size);
  inline ::std::string* mutable_prefab();
  inline ::std::string* release_prefab();
  inline void set_allocated_prefab(::std::string* prefab);

  // @@protoc_insertion_point(class_scope:NFFS.FixTimeEvent.EventTrigger)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_prefab();
  inline void clear_has_prefab();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::NFFS::FSVector3* v_;
  ::std::string* prefab_;
  float eventtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static FixTimeEvent_EventTrigger* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT FixTimeEvent_HitTrigger : public ::google::protobuf::Message {
 public:
  FixTimeEvent_HitTrigger();
  virtual ~FixTimeEvent_HitTrigger();

  FixTimeEvent_HitTrigger(const FixTimeEvent_HitTrigger& from);

  inline FixTimeEvent_HitTrigger& operator=(const FixTimeEvent_HitTrigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FixTimeEvent_HitTrigger& default_instance();

  void Swap(FixTimeEvent_HitTrigger* other);

  // implements Message ----------------------------------------------

  FixTimeEvent_HitTrigger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FixTimeEvent_HitTrigger& from);
  void MergeFrom(const FixTimeEvent_HitTrigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float hitTime = 1;
  inline bool has_hittime() const;
  inline void clear_hittime();
  static const int kHitTimeFieldNumber = 1;
  inline float hittime() const;
  inline void set_hittime(float value);

  // required string prefab = 2;
  inline bool has_prefab() const;
  inline void clear_prefab();
  static const int kPrefabFieldNumber = 2;
  inline const ::std::string& prefab() const;
  inline void set_prefab(const ::std::string& value);
  inline void set_prefab(const char* value);
  inline void set_prefab(const char* value, size_t size);
  inline ::std::string* mutable_prefab();
  inline ::std::string* release_prefab();
  inline void set_allocated_prefab(::std::string* prefab);

  // required float backHeroDis = 3;
  inline bool has_backherodis() const;
  inline void clear_backherodis();
  static const int kBackHeroDisFieldNumber = 3;
  inline float backherodis() const;
  inline void set_backherodis(float value);

  // required float backNpcDis = 4;
  inline bool has_backnpcdis() const;
  inline void clear_backnpcdis();
  static const int kBackNpcDisFieldNumber = 4;
  inline float backnpcdis() const;
  inline void set_backnpcdis(float value);

  // @@protoc_insertion_point(class_scope:NFFS.FixTimeEvent.HitTrigger)
 private:
  inline void set_has_hittime();
  inline void clear_has_hittime();
  inline void set_has_prefab();
  inline void clear_has_prefab();
  inline void set_has_backherodis();
  inline void clear_has_backherodis();
  inline void set_has_backnpcdis();
  inline void clear_has_backnpcdis();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prefab_;
  float hittime_;
  float backherodis_;
  float backnpcdis_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static FixTimeEvent_HitTrigger* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT FixTimeEvent : public ::google::protobuf::Message {
 public:
  FixTimeEvent();
  virtual ~FixTimeEvent();

  FixTimeEvent(const FixTimeEvent& from);

  inline FixTimeEvent& operator=(const FixTimeEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FixTimeEvent& default_instance();

  void Swap(FixTimeEvent* other);

  // implements Message ----------------------------------------------

  FixTimeEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FixTimeEvent& from);
  void MergeFrom(const FixTimeEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FixTimeEvent_EventTrigger EventTrigger;
  typedef FixTimeEvent_HitTrigger HitTrigger;

  // accessors -------------------------------------------------------

  // repeated .NFFS.FixTimeEvent.HitTrigger hitTrigger = 1;
  inline int hittrigger_size() const;
  inline void clear_hittrigger();
  static const int kHitTriggerFieldNumber = 1;
  inline const ::NFFS::FixTimeEvent_HitTrigger& hittrigger(int index) const;
  inline ::NFFS::FixTimeEvent_HitTrigger* mutable_hittrigger(int index);
  inline ::NFFS::FixTimeEvent_HitTrigger* add_hittrigger();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_HitTrigger >&
      hittrigger() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_HitTrigger >*
      mutable_hittrigger();

  // repeated .NFFS.FixTimeEvent.EventTrigger eventTrigger = 5;
  inline int eventtrigger_size() const;
  inline void clear_eventtrigger();
  static const int kEventTriggerFieldNumber = 5;
  inline const ::NFFS::FixTimeEvent_EventTrigger& eventtrigger(int index) const;
  inline ::NFFS::FixTimeEvent_EventTrigger* mutable_eventtrigger(int index);
  inline ::NFFS::FixTimeEvent_EventTrigger* add_eventtrigger();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_EventTrigger >&
      eventtrigger() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_EventTrigger >*
      mutable_eventtrigger();

  // @@protoc_insertion_point(class_scope:NFFS.FixTimeEvent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_HitTrigger > hittrigger_;
  ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_EventTrigger > eventtrigger_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static FixTimeEvent* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BulletEvent_TacheBomp : public ::google::protobuf::Message {
 public:
  BulletEvent_TacheBomp();
  virtual ~BulletEvent_TacheBomp();

  BulletEvent_TacheBomp(const BulletEvent_TacheBomp& from);

  inline BulletEvent_TacheBomp& operator=(const BulletEvent_TacheBomp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulletEvent_TacheBomp& default_instance();

  void Swap(BulletEvent_TacheBomp* other);

  // implements Message ----------------------------------------------

  BulletEvent_TacheBomp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulletEvent_TacheBomp& from);
  void MergeFrom(const BulletEvent_TacheBomp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float bompTime = 1;
  inline bool has_bomptime() const;
  inline void clear_bomptime();
  static const int kBompTimeFieldNumber = 1;
  inline float bomptime() const;
  inline void set_bomptime(float value);

  // required float bompRang = 2;
  inline bool has_bomprang() const;
  inline void clear_bomprang();
  static const int kBompRangFieldNumber = 2;
  inline float bomprang() const;
  inline void set_bomprang(float value);

  // required string bompPrefabPath = 3;
  inline bool has_bompprefabpath() const;
  inline void clear_bompprefabpath();
  static const int kBompPrefabPathFieldNumber = 3;
  inline const ::std::string& bompprefabpath() const;
  inline void set_bompprefabpath(const ::std::string& value);
  inline void set_bompprefabpath(const char* value);
  inline void set_bompprefabpath(const char* value, size_t size);
  inline ::std::string* mutable_bompprefabpath();
  inline ::std::string* release_bompprefabpath();
  inline void set_allocated_bompprefabpath(::std::string* bompprefabpath);

  // required string beAttackParticle = 4;
  inline bool has_beattackparticle() const;
  inline void clear_beattackparticle();
  static const int kBeAttackParticleFieldNumber = 4;
  inline const ::std::string& beattackparticle() const;
  inline void set_beattackparticle(const ::std::string& value);
  inline void set_beattackparticle(const char* value);
  inline void set_beattackparticle(const char* value, size_t size);
  inline ::std::string* mutable_beattackparticle();
  inline ::std::string* release_beattackparticle();
  inline void set_allocated_beattackparticle(::std::string* beattackparticle);

  // required float backNpcDis = 5;
  inline bool has_backnpcdis() const;
  inline void clear_backnpcdis();
  static const int kBackNpcDisFieldNumber = 5;
  inline float backnpcdis() const;
  inline void set_backnpcdis(float value);

  // required float backHeroDis = 6;
  inline bool has_backherodis() const;
  inline void clear_backherodis();
  static const int kBackHeroDisFieldNumber = 6;
  inline float backherodis() const;
  inline void set_backherodis(float value);

  // @@protoc_insertion_point(class_scope:NFFS.BulletEvent.TacheBomp)
 private:
  inline void set_has_bomptime();
  inline void clear_has_bomptime();
  inline void set_has_bomprang();
  inline void clear_has_bomprang();
  inline void set_has_bompprefabpath();
  inline void clear_has_bompprefabpath();
  inline void set_has_beattackparticle();
  inline void clear_has_beattackparticle();
  inline void set_has_backnpcdis();
  inline void clear_has_backnpcdis();
  inline void set_has_backherodis();
  inline void clear_has_backherodis();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float bomptime_;
  float bomprang_;
  ::std::string* bompprefabpath_;
  ::std::string* beattackparticle_;
  float backnpcdis_;
  float backherodis_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static BulletEvent_TacheBomp* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BulletEvent_Bullet : public ::google::protobuf::Message {
 public:
  BulletEvent_Bullet();
  virtual ~BulletEvent_Bullet();

  BulletEvent_Bullet(const BulletEvent_Bullet& from);

  inline BulletEvent_Bullet& operator=(const BulletEvent_Bullet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulletEvent_Bullet& default_instance();

  void Swap(BulletEvent_Bullet* other);

  // implements Message ----------------------------------------------

  BulletEvent_Bullet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulletEvent_Bullet& from);
  void MergeFrom(const BulletEvent_Bullet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float eventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.BulletEvent.EBEType eventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::NFFS::BulletEvent_EBEType eventtype() const;
  inline void set_eventtype(::NFFS::BulletEvent_EBEType value);

  // required float speed = 3;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline float speed() const;
  inline void set_speed(float value);

  // required float maxDis = 4;
  inline bool has_maxdis() const;
  inline void clear_maxdis();
  static const int kMaxDisFieldNumber = 4;
  inline float maxdis() const;
  inline void set_maxdis(float value);

  // required float bulletRang = 5;
  inline bool has_bulletrang() const;
  inline void clear_bulletrang();
  static const int kBulletRangFieldNumber = 5;
  inline float bulletrang() const;
  inline void set_bulletrang(float value);

  // required .NFFS.BulletEvent.EBE_BACKType bulletBackType = 6;
  inline bool has_bulletbacktype() const;
  inline void clear_bulletbacktype();
  static const int kBulletBackTypeFieldNumber = 6;
  inline ::NFFS::BulletEvent_EBE_BACKType bulletbacktype() const;
  inline void set_bulletbacktype(::NFFS::BulletEvent_EBE_BACKType value);

  // required float backHeroDis = 7;
  inline bool has_backherodis() const;
  inline void clear_backherodis();
  static const int kBackHeroDisFieldNumber = 7;
  inline float backherodis() const;
  inline void set_backherodis(float value);

  // required float backNpcDis = 8;
  inline bool has_backnpcdis() const;
  inline void clear_backnpcdis();
  static const int kBackNpcDisFieldNumber = 8;
  inline float backnpcdis() const;
  inline void set_backnpcdis(float value);

  // required int32 tacheDetroy = 9;
  inline bool has_tachedetroy() const;
  inline void clear_tachedetroy();
  static const int kTacheDetroyFieldNumber = 9;
  inline ::google::protobuf::int32 tachedetroy() const;
  inline void set_tachedetroy(::google::protobuf::int32 value);

  // required string beAttackParticle = 10;
  inline bool has_beattackparticle() const;
  inline void clear_beattackparticle();
  static const int kBeAttackParticleFieldNumber = 10;
  inline const ::std::string& beattackparticle() const;
  inline void set_beattackparticle(const ::std::string& value);
  inline void set_beattackparticle(const char* value);
  inline void set_beattackparticle(const char* value, size_t size);
  inline ::std::string* mutable_beattackparticle();
  inline ::std::string* release_beattackparticle();
  inline void set_allocated_beattackparticle(::std::string* beattackparticle);

  // required .NFFS.FSVector3 fireOffest = 11;
  inline bool has_fireoffest() const;
  inline void clear_fireoffest();
  static const int kFireOffestFieldNumber = 11;
  inline const ::NFFS::FSVector3& fireoffest() const;
  inline ::NFFS::FSVector3* mutable_fireoffest();
  inline ::NFFS::FSVector3* release_fireoffest();
  inline void set_allocated_fireoffest(::NFFS::FSVector3* fireoffest);

  // required string bulletPrefabPath = 12;
  inline bool has_bulletprefabpath() const;
  inline void clear_bulletprefabpath();
  static const int kBulletPrefabPathFieldNumber = 12;
  inline const ::std::string& bulletprefabpath() const;
  inline void set_bulletprefabpath(const ::std::string& value);
  inline void set_bulletprefabpath(const char* value);
  inline void set_bulletprefabpath(const char* value, size_t size);
  inline ::std::string* mutable_bulletprefabpath();
  inline ::std::string* release_bulletprefabpath();
  inline void set_allocated_bulletprefabpath(::std::string* bulletprefabpath);

  // required .NFFS.BulletEvent.TacheBomp bomp = 13;
  inline bool has_bomp() const;
  inline void clear_bomp();
  static const int kBompFieldNumber = 13;
  inline const ::NFFS::BulletEvent_TacheBomp& bomp() const;
  inline ::NFFS::BulletEvent_TacheBomp* mutable_bomp();
  inline ::NFFS::BulletEvent_TacheBomp* release_bomp();
  inline void set_allocated_bomp(::NFFS::BulletEvent_TacheBomp* bomp);

  // @@protoc_insertion_point(class_scope:NFFS.BulletEvent.Bullet)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_maxdis();
  inline void clear_has_maxdis();
  inline void set_has_bulletrang();
  inline void clear_has_bulletrang();
  inline void set_has_bulletbacktype();
  inline void clear_has_bulletbacktype();
  inline void set_has_backherodis();
  inline void clear_has_backherodis();
  inline void set_has_backnpcdis();
  inline void clear_has_backnpcdis();
  inline void set_has_tachedetroy();
  inline void clear_has_tachedetroy();
  inline void set_has_beattackparticle();
  inline void clear_has_beattackparticle();
  inline void set_has_fireoffest();
  inline void clear_has_fireoffest();
  inline void set_has_bulletprefabpath();
  inline void clear_has_bulletprefabpath();
  inline void set_has_bomp();
  inline void clear_has_bomp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int eventtype_;
  float speed_;
  float maxdis_;
  float bulletrang_;
  int bulletbacktype_;
  float backherodis_;
  float backnpcdis_;
  ::std::string* beattackparticle_;
  ::NFFS::FSVector3* fireoffest_;
  ::std::string* bulletprefabpath_;
  ::NFFS::BulletEvent_TacheBomp* bomp_;
  ::google::protobuf::int32 tachedetroy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static BulletEvent_Bullet* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BulletEvent : public ::google::protobuf::Message {
 public:
  BulletEvent();
  virtual ~BulletEvent();

  BulletEvent(const BulletEvent& from);

  inline BulletEvent& operator=(const BulletEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulletEvent& default_instance();

  void Swap(BulletEvent* other);

  // implements Message ----------------------------------------------

  BulletEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulletEvent& from);
  void MergeFrom(const BulletEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BulletEvent_TacheBomp TacheBomp;
  typedef BulletEvent_Bullet Bullet;

  typedef BulletEvent_EBEType EBEType;
  static const EBEType ESET_TARGET = BulletEvent_EBEType_ESET_TARGET;
  static const EBEType ESET_POSITION = BulletEvent_EBEType_ESET_POSITION;
  static inline bool EBEType_IsValid(int value) {
    return BulletEvent_EBEType_IsValid(value);
  }
  static const EBEType EBEType_MIN =
    BulletEvent_EBEType_EBEType_MIN;
  static const EBEType EBEType_MAX =
    BulletEvent_EBEType_EBEType_MAX;
  static const int EBEType_ARRAYSIZE =
    BulletEvent_EBEType_EBEType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EBEType_descriptor() {
    return BulletEvent_EBEType_descriptor();
  }
  static inline const ::std::string& EBEType_Name(EBEType value) {
    return BulletEvent_EBEType_Name(value);
  }
  static inline bool EBEType_Parse(const ::std::string& name,
      EBEType* value) {
    return BulletEvent_EBEType_Parse(name, value);
  }

  typedef BulletEvent_EBE_BACKType EBE_BACKType;
  static const EBE_BACKType EBEBT_BACK = BulletEvent_EBE_BACKType_EBEBT_BACK;
  static const EBE_BACKType EBEBT_SIDE = BulletEvent_EBE_BACKType_EBEBT_SIDE;
  static inline bool EBE_BACKType_IsValid(int value) {
    return BulletEvent_EBE_BACKType_IsValid(value);
  }
  static const EBE_BACKType EBE_BACKType_MIN =
    BulletEvent_EBE_BACKType_EBE_BACKType_MIN;
  static const EBE_BACKType EBE_BACKType_MAX =
    BulletEvent_EBE_BACKType_EBE_BACKType_MAX;
  static const int EBE_BACKType_ARRAYSIZE =
    BulletEvent_EBE_BACKType_EBE_BACKType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EBE_BACKType_descriptor() {
    return BulletEvent_EBE_BACKType_descriptor();
  }
  static inline const ::std::string& EBE_BACKType_Name(EBE_BACKType value) {
    return BulletEvent_EBE_BACKType_Name(value);
  }
  static inline bool EBE_BACKType_Parse(const ::std::string& name,
      EBE_BACKType* value) {
    return BulletEvent_EBE_BACKType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.BulletEvent.Bullet bulletList = 1;
  inline int bulletlist_size() const;
  inline void clear_bulletlist();
  static const int kBulletListFieldNumber = 1;
  inline const ::NFFS::BulletEvent_Bullet& bulletlist(int index) const;
  inline ::NFFS::BulletEvent_Bullet* mutable_bulletlist(int index);
  inline ::NFFS::BulletEvent_Bullet* add_bulletlist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvent_Bullet >&
      bulletlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvent_Bullet >*
      mutable_bulletlist();

  // @@protoc_insertion_point(class_scope:NFFS.BulletEvent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvent_Bullet > bulletlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static BulletEvent* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AudioEvent_Audio : public ::google::protobuf::Message {
 public:
  AudioEvent_Audio();
  virtual ~AudioEvent_Audio();

  AudioEvent_Audio(const AudioEvent_Audio& from);

  inline AudioEvent_Audio& operator=(const AudioEvent_Audio& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioEvent_Audio& default_instance();

  void Swap(AudioEvent_Audio* other);

  // implements Message ----------------------------------------------

  AudioEvent_Audio* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioEvent_Audio& from);
  void MergeFrom(const AudioEvent_Audio& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float eventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required string audioPrefabName = 3;
  inline bool has_audioprefabname() const;
  inline void clear_audioprefabname();
  static const int kAudioPrefabNameFieldNumber = 3;
  inline const ::std::string& audioprefabname() const;
  inline void set_audioprefabname(const ::std::string& value);
  inline void set_audioprefabname(const char* value);
  inline void set_audioprefabname(const char* value, size_t size);
  inline ::std::string* mutable_audioprefabname();
  inline ::std::string* release_audioprefabname();
  inline void set_allocated_audioprefabname(::std::string* audioprefabname);

  // @@protoc_insertion_point(class_scope:NFFS.AudioEvent.Audio)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_audioprefabname();
  inline void clear_has_audioprefabname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* audioprefabname_;
  float eventtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static AudioEvent_Audio* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AudioEvent : public ::google::protobuf::Message {
 public:
  AudioEvent();
  virtual ~AudioEvent();

  AudioEvent(const AudioEvent& from);

  inline AudioEvent& operator=(const AudioEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioEvent& default_instance();

  void Swap(AudioEvent* other);

  // implements Message ----------------------------------------------

  AudioEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioEvent& from);
  void MergeFrom(const AudioEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AudioEvent_Audio Audio;

  // accessors -------------------------------------------------------

  // repeated .NFFS.AudioEvent.Audio audioList = 1;
  inline int audiolist_size() const;
  inline void clear_audiolist();
  static const int kAudioListFieldNumber = 1;
  inline const ::NFFS::AudioEvent_Audio& audiolist(int index) const;
  inline ::NFFS::AudioEvent_Audio* mutable_audiolist(int index);
  inline ::NFFS::AudioEvent_Audio* add_audiolist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::AudioEvent_Audio >&
      audiolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::AudioEvent_Audio >*
      mutable_audiolist();

  // @@protoc_insertion_point(class_scope:NFFS.AudioEvent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::AudioEvent_Audio > audiolist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static AudioEvent* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT MoveEvent_Move : public ::google::protobuf::Message {
 public:
  MoveEvent_Move();
  virtual ~MoveEvent_Move();

  MoveEvent_Move(const MoveEvent_Move& from);

  inline MoveEvent_Move& operator=(const MoveEvent_Move& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveEvent_Move& default_instance();

  void Swap(MoveEvent_Move* other);

  // implements Message ----------------------------------------------

  MoveEvent_Move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveEvent_Move& from);
  void MergeFrom(const MoveEvent_Move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float eventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.MoveEvent.METype eventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::NFFS::MoveEvent_METype eventtype() const;
  inline void set_eventtype(::NFFS::MoveEvent_METype value);

  // required float moveDis = 3;
  inline bool has_movedis() const;
  inline void clear_movedis();
  static const int kMoveDisFieldNumber = 3;
  inline float movedis() const;
  inline void set_movedis(float value);

  // required float moveTime = 4;
  inline bool has_movetime() const;
  inline void clear_movetime();
  static const int kMoveTimeFieldNumber = 4;
  inline float movetime() const;
  inline void set_movetime(float value);

  // @@protoc_insertion_point(class_scope:NFFS.MoveEvent.Move)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_movedis();
  inline void clear_has_movedis();
  inline void set_has_movetime();
  inline void clear_has_movetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int eventtype_;
  float movedis_;
  float movetime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static MoveEvent_Move* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT MoveEvent : public ::google::protobuf::Message {
 public:
  MoveEvent();
  virtual ~MoveEvent();

  MoveEvent(const MoveEvent& from);

  inline MoveEvent& operator=(const MoveEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveEvent& default_instance();

  void Swap(MoveEvent* other);

  // implements Message ----------------------------------------------

  MoveEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveEvent& from);
  void MergeFrom(const MoveEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoveEvent_Move Move;

  typedef MoveEvent_METype METype;
  static const METype ME_FORWARD = MoveEvent_METype_ME_FORWARD;
  static const METype ME_BACK = MoveEvent_METype_ME_BACK;
  static const METype ME_LEFT = MoveEvent_METype_ME_LEFT;
  static const METype ME_RIGHT = MoveEvent_METype_ME_RIGHT;
  static inline bool METype_IsValid(int value) {
    return MoveEvent_METype_IsValid(value);
  }
  static const METype METype_MIN =
    MoveEvent_METype_METype_MIN;
  static const METype METype_MAX =
    MoveEvent_METype_METype_MAX;
  static const int METype_ARRAYSIZE =
    MoveEvent_METype_METype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  METype_descriptor() {
    return MoveEvent_METype_descriptor();
  }
  static inline const ::std::string& METype_Name(METype value) {
    return MoveEvent_METype_Name(value);
  }
  static inline bool METype_Parse(const ::std::string& name,
      METype* value) {
    return MoveEvent_METype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.MoveEvent.Move moveEvent = 1;
  inline int moveevent_size() const;
  inline void clear_moveevent();
  static const int kMoveEventFieldNumber = 1;
  inline const ::NFFS::MoveEvent_Move& moveevent(int index) const;
  inline ::NFFS::MoveEvent_Move* mutable_moveevent(int index);
  inline ::NFFS::MoveEvent_Move* add_moveevent();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::MoveEvent_Move >&
      moveevent() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::MoveEvent_Move >*
      mutable_moveevent();

  // @@protoc_insertion_point(class_scope:NFFS.MoveEvent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::MoveEvent_Move > moveevent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static MoveEvent* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT CameraEvent_Camera : public ::google::protobuf::Message {
 public:
  CameraEvent_Camera();
  virtual ~CameraEvent_Camera();

  CameraEvent_Camera(const CameraEvent_Camera& from);

  inline CameraEvent_Camera& operator=(const CameraEvent_Camera& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraEvent_Camera& default_instance();

  void Swap(CameraEvent_Camera* other);

  // implements Message ----------------------------------------------

  CameraEvent_Camera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraEvent_Camera& from);
  void MergeFrom(const CameraEvent_Camera& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float eventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.CameraEvent.CEType eventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::NFFS::CameraEvent_CEType eventtype() const;
  inline void set_eventtype(::NFFS::CameraEvent_CEType value);

  // required .NFFS.FSVector3 amountParam = 3;
  inline bool has_amountparam() const;
  inline void clear_amountparam();
  static const int kAmountParamFieldNumber = 3;
  inline const ::NFFS::FSVector3& amountparam() const;
  inline ::NFFS::FSVector3* mutable_amountparam();
  inline ::NFFS::FSVector3* release_amountparam();
  inline void set_allocated_amountparam(::NFFS::FSVector3* amountparam);

  // required float shakeTime = 4;
  inline bool has_shaketime() const;
  inline void clear_shaketime();
  static const int kShakeTimeFieldNumber = 4;
  inline float shaketime() const;
  inline void set_shaketime(float value);

  // @@protoc_insertion_point(class_scope:NFFS.CameraEvent.Camera)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_amountparam();
  inline void clear_has_amountparam();
  inline void set_has_shaketime();
  inline void clear_has_shaketime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int eventtype_;
  ::NFFS::FSVector3* amountparam_;
  float shaketime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static CameraEvent_Camera* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT CameraEvent : public ::google::protobuf::Message {
 public:
  CameraEvent();
  virtual ~CameraEvent();

  CameraEvent(const CameraEvent& from);

  inline CameraEvent& operator=(const CameraEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraEvent& default_instance();

  void Swap(CameraEvent* other);

  // implements Message ----------------------------------------------

  CameraEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraEvent& from);
  void MergeFrom(const CameraEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CameraEvent_Camera Camera;

  typedef CameraEvent_CEType CEType;
  static const CEType Earthquake = CameraEvent_CEType_Earthquake;
  static const CEType Explosion = CameraEvent_CEType_Explosion;
  static const CEType No = CameraEvent_CEType_No;
  static const CEType FireKick = CameraEvent_CEType_FireKick;
  static const CEType Stomp = CameraEvent_CEType_Stomp;
  static const CEType Yes = CameraEvent_CEType_Yes;
  static const CEType SprintShake = CameraEvent_CEType_SprintShake;
  static const CEType FreeMode = CameraEvent_CEType_FreeMode;
  static const CEType MainRPGMode = CameraEvent_CEType_MainRPGMode;
  static inline bool CEType_IsValid(int value) {
    return CameraEvent_CEType_IsValid(value);
  }
  static const CEType CEType_MIN =
    CameraEvent_CEType_CEType_MIN;
  static const CEType CEType_MAX =
    CameraEvent_CEType_CEType_MAX;
  static const int CEType_ARRAYSIZE =
    CameraEvent_CEType_CEType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CEType_descriptor() {
    return CameraEvent_CEType_descriptor();
  }
  static inline const ::std::string& CEType_Name(CEType value) {
    return CameraEvent_CEType_Name(value);
  }
  static inline bool CEType_Parse(const ::std::string& name,
      CEType* value) {
    return CameraEvent_CEType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.CameraEvent.Camera cameraEventList = 1;
  inline int cameraeventlist_size() const;
  inline void clear_cameraeventlist();
  static const int kCameraEventListFieldNumber = 1;
  inline const ::NFFS::CameraEvent_Camera& cameraeventlist(int index) const;
  inline ::NFFS::CameraEvent_Camera* mutable_cameraeventlist(int index);
  inline ::NFFS::CameraEvent_Camera* add_cameraeventlist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::CameraEvent_Camera >&
      cameraeventlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::CameraEvent_Camera >*
      mutable_cameraeventlist();

  // @@protoc_insertion_point(class_scope:NFFS.CameraEvent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::CameraEvent_Camera > cameraeventlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static CameraEvent* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT EnableEvents_Enable : public ::google::protobuf::Message {
 public:
  EnableEvents_Enable();
  virtual ~EnableEvents_Enable();

  EnableEvents_Enable(const EnableEvents_Enable& from);

  inline EnableEvents_Enable& operator=(const EnableEvents_Enable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableEvents_Enable& default_instance();

  void Swap(EnableEvents_Enable* other);

  // implements Message ----------------------------------------------

  EnableEvents_Enable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnableEvents_Enable& from);
  void MergeFrom(const EnableEvents_Enable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float eventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.EnableEvents.EEETYPE eventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::NFFS::EnableEvents_EEETYPE eventtype() const;
  inline void set_eventtype(::NFFS::EnableEvents_EEETYPE value);

  // required string targetName = 3;
  inline bool has_targetname() const;
  inline void clear_targetname();
  static const int kTargetNameFieldNumber = 3;
  inline const ::std::string& targetname() const;
  inline void set_targetname(const ::std::string& value);
  inline void set_targetname(const char* value);
  inline void set_targetname(const char* value, size_t size);
  inline ::std::string* mutable_targetname();
  inline ::std::string* release_targetname();
  inline void set_allocated_targetname(::std::string* targetname);

  // @@protoc_insertion_point(class_scope:NFFS.EnableEvents.Enable)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_targetname();
  inline void clear_has_targetname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int eventtype_;
  ::std::string* targetname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static EnableEvents_Enable* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT EnableEvents : public ::google::protobuf::Message {
 public:
  EnableEvents();
  virtual ~EnableEvents();

  EnableEvents(const EnableEvents& from);

  inline EnableEvents& operator=(const EnableEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableEvents& default_instance();

  void Swap(EnableEvents* other);

  // implements Message ----------------------------------------------

  EnableEvents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnableEvents& from);
  void MergeFrom(const EnableEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EnableEvents_Enable Enable;

  typedef EnableEvents_EEETYPE EEETYPE;
  static const EEETYPE INIT = EnableEvents_EEETYPE_INIT;
  static const EEETYPE FINAL = EnableEvents_EEETYPE_FINAL;
  static inline bool EEETYPE_IsValid(int value) {
    return EnableEvents_EEETYPE_IsValid(value);
  }
  static const EEETYPE EEETYPE_MIN =
    EnableEvents_EEETYPE_EEETYPE_MIN;
  static const EEETYPE EEETYPE_MAX =
    EnableEvents_EEETYPE_EEETYPE_MAX;
  static const int EEETYPE_ARRAYSIZE =
    EnableEvents_EEETYPE_EEETYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EEETYPE_descriptor() {
    return EnableEvents_EEETYPE_descriptor();
  }
  static inline const ::std::string& EEETYPE_Name(EEETYPE value) {
    return EnableEvents_EEETYPE_Name(value);
  }
  static inline bool EEETYPE_Parse(const ::std::string& name,
      EEETYPE* value) {
    return EnableEvents_EEETYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.EnableEvents.Enable enableList = 1;
  inline int enablelist_size() const;
  inline void clear_enablelist();
  static const int kEnableListFieldNumber = 1;
  inline const ::NFFS::EnableEvents_Enable& enablelist(int index) const;
  inline ::NFFS::EnableEvents_Enable* mutable_enablelist(int index);
  inline ::NFFS::EnableEvents_Enable* add_enablelist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable >&
      enablelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable >*
      mutable_enablelist();

  // @@protoc_insertion_point(class_scope:NFFS.EnableEvents)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable > enablelist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static EnableEvents* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT GlobalSpeed_Speed : public ::google::protobuf::Message {
 public:
  GlobalSpeed_Speed();
  virtual ~GlobalSpeed_Speed();

  GlobalSpeed_Speed(const GlobalSpeed_Speed& from);

  inline GlobalSpeed_Speed& operator=(const GlobalSpeed_Speed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalSpeed_Speed& default_instance();

  void Swap(GlobalSpeed_Speed* other);

  // implements Message ----------------------------------------------

  GlobalSpeed_Speed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalSpeed_Speed& from);
  void MergeFrom(const GlobalSpeed_Speed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float eventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.GlobalSpeed.EGSTYPE eventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::NFFS::GlobalSpeed_EGSTYPE eventtype() const;
  inline void set_eventtype(::NFFS::GlobalSpeed_EGSTYPE value);

  // required float speedValue = 3;
  inline bool has_speedvalue() const;
  inline void clear_speedvalue();
  static const int kSpeedValueFieldNumber = 3;
  inline float speedvalue() const;
  inline void set_speedvalue(float value);

  // @@protoc_insertion_point(class_scope:NFFS.GlobalSpeed.Speed)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_speedvalue();
  inline void clear_has_speedvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int eventtype_;
  float speedvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static GlobalSpeed_Speed* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT GlobalSpeed : public ::google::protobuf::Message {
 public:
  GlobalSpeed();
  virtual ~GlobalSpeed();

  GlobalSpeed(const GlobalSpeed& from);

  inline GlobalSpeed& operator=(const GlobalSpeed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalSpeed& default_instance();

  void Swap(GlobalSpeed* other);

  // implements Message ----------------------------------------------

  GlobalSpeed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalSpeed& from);
  void MergeFrom(const GlobalSpeed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GlobalSpeed_Speed Speed;

  typedef GlobalSpeed_EGSTYPE EGSTYPE;
  static const EGSTYPE INIT = GlobalSpeed_EGSTYPE_INIT;
  static const EGSTYPE FINAL = GlobalSpeed_EGSTYPE_FINAL;
  static inline bool EGSTYPE_IsValid(int value) {
    return GlobalSpeed_EGSTYPE_IsValid(value);
  }
  static const EGSTYPE EGSTYPE_MIN =
    GlobalSpeed_EGSTYPE_EGSTYPE_MIN;
  static const EGSTYPE EGSTYPE_MAX =
    GlobalSpeed_EGSTYPE_EGSTYPE_MAX;
  static const int EGSTYPE_ARRAYSIZE =
    GlobalSpeed_EGSTYPE_EGSTYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGSTYPE_descriptor() {
    return GlobalSpeed_EGSTYPE_descriptor();
  }
  static inline const ::std::string& EGSTYPE_Name(EGSTYPE value) {
    return GlobalSpeed_EGSTYPE_Name(value);
  }
  static inline bool EGSTYPE_Parse(const ::std::string& name,
      EGSTYPE* value) {
    return GlobalSpeed_EGSTYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.GlobalSpeed.Speed speedList = 1;
  inline int speedlist_size() const;
  inline void clear_speedlist();
  static const int kSpeedListFieldNumber = 1;
  inline const ::NFFS::GlobalSpeed_Speed& speedlist(int index) const;
  inline ::NFFS::GlobalSpeed_Speed* mutable_speedlist(int index);
  inline ::NFFS::GlobalSpeed_Speed* add_speedlist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::GlobalSpeed_Speed >&
      speedlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::GlobalSpeed_Speed >*
      mutable_speedlist();

  // @@protoc_insertion_point(class_scope:NFFS.GlobalSpeed)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::GlobalSpeed_Speed > speedlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static GlobalSpeed* default_instance_;
};
// ===================================================================


// ===================================================================

// FSVector3

// required float x = 1;
inline bool FSVector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FSVector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FSVector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FSVector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float FSVector3::x() const {
  return x_;
}
inline void FSVector3::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool FSVector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FSVector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FSVector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FSVector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float FSVector3::y() const {
  return y_;
}
inline void FSVector3::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool FSVector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FSVector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FSVector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FSVector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float FSVector3::z() const {
  return z_;
}
inline void FSVector3::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// FixTimeEvent_EventTrigger

// required float eventTime = 1;
inline bool FixTimeEvent_EventTrigger::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixTimeEvent_EventTrigger::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixTimeEvent_EventTrigger::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixTimeEvent_EventTrigger::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float FixTimeEvent_EventTrigger::eventtime() const {
  return eventtime_;
}
inline void FixTimeEvent_EventTrigger::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.FSVector3 v = 2;
inline bool FixTimeEvent_EventTrigger::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FixTimeEvent_EventTrigger::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FixTimeEvent_EventTrigger::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FixTimeEvent_EventTrigger::clear_v() {
  if (v_ != NULL) v_->::NFFS::FSVector3::Clear();
  clear_has_v();
}
inline const ::NFFS::FSVector3& FixTimeEvent_EventTrigger::v() const {
  return v_ != NULL ? *v_ : *default_instance_->v_;
}
inline ::NFFS::FSVector3* FixTimeEvent_EventTrigger::mutable_v() {
  set_has_v();
  if (v_ == NULL) v_ = new ::NFFS::FSVector3;
  return v_;
}
inline ::NFFS::FSVector3* FixTimeEvent_EventTrigger::release_v() {
  clear_has_v();
  ::NFFS::FSVector3* temp = v_;
  v_ = NULL;
  return temp;
}
inline void FixTimeEvent_EventTrigger::set_allocated_v(::NFFS::FSVector3* v) {
  delete v_;
  v_ = v;
  if (v) {
    set_has_v();
  } else {
    clear_has_v();
  }
}

// required string prefab = 3;
inline bool FixTimeEvent_EventTrigger::has_prefab() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FixTimeEvent_EventTrigger::set_has_prefab() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FixTimeEvent_EventTrigger::clear_has_prefab() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FixTimeEvent_EventTrigger::clear_prefab() {
  if (prefab_ != &::google::protobuf::internal::kEmptyString) {
    prefab_->clear();
  }
  clear_has_prefab();
}
inline const ::std::string& FixTimeEvent_EventTrigger::prefab() const {
  return *prefab_;
}
inline void FixTimeEvent_EventTrigger::set_prefab(const ::std::string& value) {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    prefab_ = new ::std::string;
  }
  prefab_->assign(value);
}
inline void FixTimeEvent_EventTrigger::set_prefab(const char* value) {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    prefab_ = new ::std::string;
  }
  prefab_->assign(value);
}
inline void FixTimeEvent_EventTrigger::set_prefab(const char* value, size_t size) {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    prefab_ = new ::std::string;
  }
  prefab_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixTimeEvent_EventTrigger::mutable_prefab() {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    prefab_ = new ::std::string;
  }
  return prefab_;
}
inline ::std::string* FixTimeEvent_EventTrigger::release_prefab() {
  clear_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefab_;
    prefab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FixTimeEvent_EventTrigger::set_allocated_prefab(::std::string* prefab) {
  if (prefab_ != &::google::protobuf::internal::kEmptyString) {
    delete prefab_;
  }
  if (prefab) {
    set_has_prefab();
    prefab_ = prefab;
  } else {
    clear_has_prefab();
    prefab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FixTimeEvent_HitTrigger

// required float hitTime = 1;
inline bool FixTimeEvent_HitTrigger::has_hittime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixTimeEvent_HitTrigger::set_has_hittime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixTimeEvent_HitTrigger::clear_has_hittime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixTimeEvent_HitTrigger::clear_hittime() {
  hittime_ = 0;
  clear_has_hittime();
}
inline float FixTimeEvent_HitTrigger::hittime() const {
  return hittime_;
}
inline void FixTimeEvent_HitTrigger::set_hittime(float value) {
  set_has_hittime();
  hittime_ = value;
}

// required string prefab = 2;
inline bool FixTimeEvent_HitTrigger::has_prefab() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FixTimeEvent_HitTrigger::set_has_prefab() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FixTimeEvent_HitTrigger::clear_has_prefab() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FixTimeEvent_HitTrigger::clear_prefab() {
  if (prefab_ != &::google::protobuf::internal::kEmptyString) {
    prefab_->clear();
  }
  clear_has_prefab();
}
inline const ::std::string& FixTimeEvent_HitTrigger::prefab() const {
  return *prefab_;
}
inline void FixTimeEvent_HitTrigger::set_prefab(const ::std::string& value) {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    prefab_ = new ::std::string;
  }
  prefab_->assign(value);
}
inline void FixTimeEvent_HitTrigger::set_prefab(const char* value) {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    prefab_ = new ::std::string;
  }
  prefab_->assign(value);
}
inline void FixTimeEvent_HitTrigger::set_prefab(const char* value, size_t size) {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    prefab_ = new ::std::string;
  }
  prefab_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixTimeEvent_HitTrigger::mutable_prefab() {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    prefab_ = new ::std::string;
  }
  return prefab_;
}
inline ::std::string* FixTimeEvent_HitTrigger::release_prefab() {
  clear_has_prefab();
  if (prefab_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefab_;
    prefab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FixTimeEvent_HitTrigger::set_allocated_prefab(::std::string* prefab) {
  if (prefab_ != &::google::protobuf::internal::kEmptyString) {
    delete prefab_;
  }
  if (prefab) {
    set_has_prefab();
    prefab_ = prefab;
  } else {
    clear_has_prefab();
    prefab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float backHeroDis = 3;
inline bool FixTimeEvent_HitTrigger::has_backherodis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FixTimeEvent_HitTrigger::set_has_backherodis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FixTimeEvent_HitTrigger::clear_has_backherodis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FixTimeEvent_HitTrigger::clear_backherodis() {
  backherodis_ = 0;
  clear_has_backherodis();
}
inline float FixTimeEvent_HitTrigger::backherodis() const {
  return backherodis_;
}
inline void FixTimeEvent_HitTrigger::set_backherodis(float value) {
  set_has_backherodis();
  backherodis_ = value;
}

// required float backNpcDis = 4;
inline bool FixTimeEvent_HitTrigger::has_backnpcdis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FixTimeEvent_HitTrigger::set_has_backnpcdis() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FixTimeEvent_HitTrigger::clear_has_backnpcdis() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FixTimeEvent_HitTrigger::clear_backnpcdis() {
  backnpcdis_ = 0;
  clear_has_backnpcdis();
}
inline float FixTimeEvent_HitTrigger::backnpcdis() const {
  return backnpcdis_;
}
inline void FixTimeEvent_HitTrigger::set_backnpcdis(float value) {
  set_has_backnpcdis();
  backnpcdis_ = value;
}

// -------------------------------------------------------------------

// FixTimeEvent

// repeated .NFFS.FixTimeEvent.HitTrigger hitTrigger = 1;
inline int FixTimeEvent::hittrigger_size() const {
  return hittrigger_.size();
}
inline void FixTimeEvent::clear_hittrigger() {
  hittrigger_.Clear();
}
inline const ::NFFS::FixTimeEvent_HitTrigger& FixTimeEvent::hittrigger(int index) const {
  return hittrigger_.Get(index);
}
inline ::NFFS::FixTimeEvent_HitTrigger* FixTimeEvent::mutable_hittrigger(int index) {
  return hittrigger_.Mutable(index);
}
inline ::NFFS::FixTimeEvent_HitTrigger* FixTimeEvent::add_hittrigger() {
  return hittrigger_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_HitTrigger >&
FixTimeEvent::hittrigger() const {
  return hittrigger_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_HitTrigger >*
FixTimeEvent::mutable_hittrigger() {
  return &hittrigger_;
}

// repeated .NFFS.FixTimeEvent.EventTrigger eventTrigger = 5;
inline int FixTimeEvent::eventtrigger_size() const {
  return eventtrigger_.size();
}
inline void FixTimeEvent::clear_eventtrigger() {
  eventtrigger_.Clear();
}
inline const ::NFFS::FixTimeEvent_EventTrigger& FixTimeEvent::eventtrigger(int index) const {
  return eventtrigger_.Get(index);
}
inline ::NFFS::FixTimeEvent_EventTrigger* FixTimeEvent::mutable_eventtrigger(int index) {
  return eventtrigger_.Mutable(index);
}
inline ::NFFS::FixTimeEvent_EventTrigger* FixTimeEvent::add_eventtrigger() {
  return eventtrigger_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_EventTrigger >&
FixTimeEvent::eventtrigger() const {
  return eventtrigger_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::FixTimeEvent_EventTrigger >*
FixTimeEvent::mutable_eventtrigger() {
  return &eventtrigger_;
}

// -------------------------------------------------------------------

// BulletEvent_TacheBomp

// required float bompTime = 1;
inline bool BulletEvent_TacheBomp::has_bomptime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulletEvent_TacheBomp::set_has_bomptime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BulletEvent_TacheBomp::clear_has_bomptime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BulletEvent_TacheBomp::clear_bomptime() {
  bomptime_ = 0;
  clear_has_bomptime();
}
inline float BulletEvent_TacheBomp::bomptime() const {
  return bomptime_;
}
inline void BulletEvent_TacheBomp::set_bomptime(float value) {
  set_has_bomptime();
  bomptime_ = value;
}

// required float bompRang = 2;
inline bool BulletEvent_TacheBomp::has_bomprang() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BulletEvent_TacheBomp::set_has_bomprang() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BulletEvent_TacheBomp::clear_has_bomprang() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BulletEvent_TacheBomp::clear_bomprang() {
  bomprang_ = 0;
  clear_has_bomprang();
}
inline float BulletEvent_TacheBomp::bomprang() const {
  return bomprang_;
}
inline void BulletEvent_TacheBomp::set_bomprang(float value) {
  set_has_bomprang();
  bomprang_ = value;
}

// required string bompPrefabPath = 3;
inline bool BulletEvent_TacheBomp::has_bompprefabpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BulletEvent_TacheBomp::set_has_bompprefabpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BulletEvent_TacheBomp::clear_has_bompprefabpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BulletEvent_TacheBomp::clear_bompprefabpath() {
  if (bompprefabpath_ != &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_->clear();
  }
  clear_has_bompprefabpath();
}
inline const ::std::string& BulletEvent_TacheBomp::bompprefabpath() const {
  return *bompprefabpath_;
}
inline void BulletEvent_TacheBomp::set_bompprefabpath(const ::std::string& value) {
  set_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_ = new ::std::string;
  }
  bompprefabpath_->assign(value);
}
inline void BulletEvent_TacheBomp::set_bompprefabpath(const char* value) {
  set_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_ = new ::std::string;
  }
  bompprefabpath_->assign(value);
}
inline void BulletEvent_TacheBomp::set_bompprefabpath(const char* value, size_t size) {
  set_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_ = new ::std::string;
  }
  bompprefabpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvent_TacheBomp::mutable_bompprefabpath() {
  set_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_ = new ::std::string;
  }
  return bompprefabpath_;
}
inline ::std::string* BulletEvent_TacheBomp::release_bompprefabpath() {
  clear_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bompprefabpath_;
    bompprefabpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvent_TacheBomp::set_allocated_bompprefabpath(::std::string* bompprefabpath) {
  if (bompprefabpath_ != &::google::protobuf::internal::kEmptyString) {
    delete bompprefabpath_;
  }
  if (bompprefabpath) {
    set_has_bompprefabpath();
    bompprefabpath_ = bompprefabpath;
  } else {
    clear_has_bompprefabpath();
    bompprefabpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string beAttackParticle = 4;
inline bool BulletEvent_TacheBomp::has_beattackparticle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BulletEvent_TacheBomp::set_has_beattackparticle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BulletEvent_TacheBomp::clear_has_beattackparticle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BulletEvent_TacheBomp::clear_beattackparticle() {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    beattackparticle_->clear();
  }
  clear_has_beattackparticle();
}
inline const ::std::string& BulletEvent_TacheBomp::beattackparticle() const {
  return *beattackparticle_;
}
inline void BulletEvent_TacheBomp::set_beattackparticle(const ::std::string& value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void BulletEvent_TacheBomp::set_beattackparticle(const char* value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void BulletEvent_TacheBomp::set_beattackparticle(const char* value, size_t size) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvent_TacheBomp::mutable_beattackparticle() {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  return beattackparticle_;
}
inline ::std::string* BulletEvent_TacheBomp::release_beattackparticle() {
  clear_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beattackparticle_;
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvent_TacheBomp::set_allocated_beattackparticle(::std::string* beattackparticle) {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    delete beattackparticle_;
  }
  if (beattackparticle) {
    set_has_beattackparticle();
    beattackparticle_ = beattackparticle;
  } else {
    clear_has_beattackparticle();
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float backNpcDis = 5;
inline bool BulletEvent_TacheBomp::has_backnpcdis() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BulletEvent_TacheBomp::set_has_backnpcdis() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BulletEvent_TacheBomp::clear_has_backnpcdis() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BulletEvent_TacheBomp::clear_backnpcdis() {
  backnpcdis_ = 0;
  clear_has_backnpcdis();
}
inline float BulletEvent_TacheBomp::backnpcdis() const {
  return backnpcdis_;
}
inline void BulletEvent_TacheBomp::set_backnpcdis(float value) {
  set_has_backnpcdis();
  backnpcdis_ = value;
}

// required float backHeroDis = 6;
inline bool BulletEvent_TacheBomp::has_backherodis() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BulletEvent_TacheBomp::set_has_backherodis() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BulletEvent_TacheBomp::clear_has_backherodis() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BulletEvent_TacheBomp::clear_backherodis() {
  backherodis_ = 0;
  clear_has_backherodis();
}
inline float BulletEvent_TacheBomp::backherodis() const {
  return backherodis_;
}
inline void BulletEvent_TacheBomp::set_backherodis(float value) {
  set_has_backherodis();
  backherodis_ = value;
}

// -------------------------------------------------------------------

// BulletEvent_Bullet

// required float eventTime = 1;
inline bool BulletEvent_Bullet::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulletEvent_Bullet::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BulletEvent_Bullet::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BulletEvent_Bullet::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float BulletEvent_Bullet::eventtime() const {
  return eventtime_;
}
inline void BulletEvent_Bullet::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.BulletEvent.EBEType eventType = 2;
inline bool BulletEvent_Bullet::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BulletEvent_Bullet::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BulletEvent_Bullet::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BulletEvent_Bullet::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::BulletEvent_EBEType BulletEvent_Bullet::eventtype() const {
  return static_cast< ::NFFS::BulletEvent_EBEType >(eventtype_);
}
inline void BulletEvent_Bullet::set_eventtype(::NFFS::BulletEvent_EBEType value) {
  assert(::NFFS::BulletEvent_EBEType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required float speed = 3;
inline bool BulletEvent_Bullet::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BulletEvent_Bullet::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BulletEvent_Bullet::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BulletEvent_Bullet::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float BulletEvent_Bullet::speed() const {
  return speed_;
}
inline void BulletEvent_Bullet::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// required float maxDis = 4;
inline bool BulletEvent_Bullet::has_maxdis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BulletEvent_Bullet::set_has_maxdis() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BulletEvent_Bullet::clear_has_maxdis() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BulletEvent_Bullet::clear_maxdis() {
  maxdis_ = 0;
  clear_has_maxdis();
}
inline float BulletEvent_Bullet::maxdis() const {
  return maxdis_;
}
inline void BulletEvent_Bullet::set_maxdis(float value) {
  set_has_maxdis();
  maxdis_ = value;
}

// required float bulletRang = 5;
inline bool BulletEvent_Bullet::has_bulletrang() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BulletEvent_Bullet::set_has_bulletrang() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BulletEvent_Bullet::clear_has_bulletrang() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BulletEvent_Bullet::clear_bulletrang() {
  bulletrang_ = 0;
  clear_has_bulletrang();
}
inline float BulletEvent_Bullet::bulletrang() const {
  return bulletrang_;
}
inline void BulletEvent_Bullet::set_bulletrang(float value) {
  set_has_bulletrang();
  bulletrang_ = value;
}

// required .NFFS.BulletEvent.EBE_BACKType bulletBackType = 6;
inline bool BulletEvent_Bullet::has_bulletbacktype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BulletEvent_Bullet::set_has_bulletbacktype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BulletEvent_Bullet::clear_has_bulletbacktype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BulletEvent_Bullet::clear_bulletbacktype() {
  bulletbacktype_ = 0;
  clear_has_bulletbacktype();
}
inline ::NFFS::BulletEvent_EBE_BACKType BulletEvent_Bullet::bulletbacktype() const {
  return static_cast< ::NFFS::BulletEvent_EBE_BACKType >(bulletbacktype_);
}
inline void BulletEvent_Bullet::set_bulletbacktype(::NFFS::BulletEvent_EBE_BACKType value) {
  assert(::NFFS::BulletEvent_EBE_BACKType_IsValid(value));
  set_has_bulletbacktype();
  bulletbacktype_ = value;
}

// required float backHeroDis = 7;
inline bool BulletEvent_Bullet::has_backherodis() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BulletEvent_Bullet::set_has_backherodis() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BulletEvent_Bullet::clear_has_backherodis() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BulletEvent_Bullet::clear_backherodis() {
  backherodis_ = 0;
  clear_has_backherodis();
}
inline float BulletEvent_Bullet::backherodis() const {
  return backherodis_;
}
inline void BulletEvent_Bullet::set_backherodis(float value) {
  set_has_backherodis();
  backherodis_ = value;
}

// required float backNpcDis = 8;
inline bool BulletEvent_Bullet::has_backnpcdis() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BulletEvent_Bullet::set_has_backnpcdis() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BulletEvent_Bullet::clear_has_backnpcdis() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BulletEvent_Bullet::clear_backnpcdis() {
  backnpcdis_ = 0;
  clear_has_backnpcdis();
}
inline float BulletEvent_Bullet::backnpcdis() const {
  return backnpcdis_;
}
inline void BulletEvent_Bullet::set_backnpcdis(float value) {
  set_has_backnpcdis();
  backnpcdis_ = value;
}

// required int32 tacheDetroy = 9;
inline bool BulletEvent_Bullet::has_tachedetroy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BulletEvent_Bullet::set_has_tachedetroy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BulletEvent_Bullet::clear_has_tachedetroy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BulletEvent_Bullet::clear_tachedetroy() {
  tachedetroy_ = 0;
  clear_has_tachedetroy();
}
inline ::google::protobuf::int32 BulletEvent_Bullet::tachedetroy() const {
  return tachedetroy_;
}
inline void BulletEvent_Bullet::set_tachedetroy(::google::protobuf::int32 value) {
  set_has_tachedetroy();
  tachedetroy_ = value;
}

// required string beAttackParticle = 10;
inline bool BulletEvent_Bullet::has_beattackparticle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BulletEvent_Bullet::set_has_beattackparticle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BulletEvent_Bullet::clear_has_beattackparticle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BulletEvent_Bullet::clear_beattackparticle() {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    beattackparticle_->clear();
  }
  clear_has_beattackparticle();
}
inline const ::std::string& BulletEvent_Bullet::beattackparticle() const {
  return *beattackparticle_;
}
inline void BulletEvent_Bullet::set_beattackparticle(const ::std::string& value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void BulletEvent_Bullet::set_beattackparticle(const char* value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void BulletEvent_Bullet::set_beattackparticle(const char* value, size_t size) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvent_Bullet::mutable_beattackparticle() {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  return beattackparticle_;
}
inline ::std::string* BulletEvent_Bullet::release_beattackparticle() {
  clear_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beattackparticle_;
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvent_Bullet::set_allocated_beattackparticle(::std::string* beattackparticle) {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    delete beattackparticle_;
  }
  if (beattackparticle) {
    set_has_beattackparticle();
    beattackparticle_ = beattackparticle;
  } else {
    clear_has_beattackparticle();
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .NFFS.FSVector3 fireOffest = 11;
inline bool BulletEvent_Bullet::has_fireoffest() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BulletEvent_Bullet::set_has_fireoffest() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BulletEvent_Bullet::clear_has_fireoffest() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BulletEvent_Bullet::clear_fireoffest() {
  if (fireoffest_ != NULL) fireoffest_->::NFFS::FSVector3::Clear();
  clear_has_fireoffest();
}
inline const ::NFFS::FSVector3& BulletEvent_Bullet::fireoffest() const {
  return fireoffest_ != NULL ? *fireoffest_ : *default_instance_->fireoffest_;
}
inline ::NFFS::FSVector3* BulletEvent_Bullet::mutable_fireoffest() {
  set_has_fireoffest();
  if (fireoffest_ == NULL) fireoffest_ = new ::NFFS::FSVector3;
  return fireoffest_;
}
inline ::NFFS::FSVector3* BulletEvent_Bullet::release_fireoffest() {
  clear_has_fireoffest();
  ::NFFS::FSVector3* temp = fireoffest_;
  fireoffest_ = NULL;
  return temp;
}
inline void BulletEvent_Bullet::set_allocated_fireoffest(::NFFS::FSVector3* fireoffest) {
  delete fireoffest_;
  fireoffest_ = fireoffest;
  if (fireoffest) {
    set_has_fireoffest();
  } else {
    clear_has_fireoffest();
  }
}

// required string bulletPrefabPath = 12;
inline bool BulletEvent_Bullet::has_bulletprefabpath() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BulletEvent_Bullet::set_has_bulletprefabpath() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BulletEvent_Bullet::clear_has_bulletprefabpath() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BulletEvent_Bullet::clear_bulletprefabpath() {
  if (bulletprefabpath_ != &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_->clear();
  }
  clear_has_bulletprefabpath();
}
inline const ::std::string& BulletEvent_Bullet::bulletprefabpath() const {
  return *bulletprefabpath_;
}
inline void BulletEvent_Bullet::set_bulletprefabpath(const ::std::string& value) {
  set_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_ = new ::std::string;
  }
  bulletprefabpath_->assign(value);
}
inline void BulletEvent_Bullet::set_bulletprefabpath(const char* value) {
  set_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_ = new ::std::string;
  }
  bulletprefabpath_->assign(value);
}
inline void BulletEvent_Bullet::set_bulletprefabpath(const char* value, size_t size) {
  set_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_ = new ::std::string;
  }
  bulletprefabpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvent_Bullet::mutable_bulletprefabpath() {
  set_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_ = new ::std::string;
  }
  return bulletprefabpath_;
}
inline ::std::string* BulletEvent_Bullet::release_bulletprefabpath() {
  clear_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bulletprefabpath_;
    bulletprefabpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvent_Bullet::set_allocated_bulletprefabpath(::std::string* bulletprefabpath) {
  if (bulletprefabpath_ != &::google::protobuf::internal::kEmptyString) {
    delete bulletprefabpath_;
  }
  if (bulletprefabpath) {
    set_has_bulletprefabpath();
    bulletprefabpath_ = bulletprefabpath;
  } else {
    clear_has_bulletprefabpath();
    bulletprefabpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .NFFS.BulletEvent.TacheBomp bomp = 13;
inline bool BulletEvent_Bullet::has_bomp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BulletEvent_Bullet::set_has_bomp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BulletEvent_Bullet::clear_has_bomp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BulletEvent_Bullet::clear_bomp() {
  if (bomp_ != NULL) bomp_->::NFFS::BulletEvent_TacheBomp::Clear();
  clear_has_bomp();
}
inline const ::NFFS::BulletEvent_TacheBomp& BulletEvent_Bullet::bomp() const {
  return bomp_ != NULL ? *bomp_ : *default_instance_->bomp_;
}
inline ::NFFS::BulletEvent_TacheBomp* BulletEvent_Bullet::mutable_bomp() {
  set_has_bomp();
  if (bomp_ == NULL) bomp_ = new ::NFFS::BulletEvent_TacheBomp;
  return bomp_;
}
inline ::NFFS::BulletEvent_TacheBomp* BulletEvent_Bullet::release_bomp() {
  clear_has_bomp();
  ::NFFS::BulletEvent_TacheBomp* temp = bomp_;
  bomp_ = NULL;
  return temp;
}
inline void BulletEvent_Bullet::set_allocated_bomp(::NFFS::BulletEvent_TacheBomp* bomp) {
  delete bomp_;
  bomp_ = bomp;
  if (bomp) {
    set_has_bomp();
  } else {
    clear_has_bomp();
  }
}

// -------------------------------------------------------------------

// BulletEvent

// repeated .NFFS.BulletEvent.Bullet bulletList = 1;
inline int BulletEvent::bulletlist_size() const {
  return bulletlist_.size();
}
inline void BulletEvent::clear_bulletlist() {
  bulletlist_.Clear();
}
inline const ::NFFS::BulletEvent_Bullet& BulletEvent::bulletlist(int index) const {
  return bulletlist_.Get(index);
}
inline ::NFFS::BulletEvent_Bullet* BulletEvent::mutable_bulletlist(int index) {
  return bulletlist_.Mutable(index);
}
inline ::NFFS::BulletEvent_Bullet* BulletEvent::add_bulletlist() {
  return bulletlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvent_Bullet >&
BulletEvent::bulletlist() const {
  return bulletlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvent_Bullet >*
BulletEvent::mutable_bulletlist() {
  return &bulletlist_;
}

// -------------------------------------------------------------------

// AudioEvent_Audio

// required float eventTime = 1;
inline bool AudioEvent_Audio::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioEvent_Audio::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioEvent_Audio::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioEvent_Audio::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float AudioEvent_Audio::eventtime() const {
  return eventtime_;
}
inline void AudioEvent_Audio::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required string audioPrefabName = 3;
inline bool AudioEvent_Audio::has_audioprefabname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioEvent_Audio::set_has_audioprefabname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioEvent_Audio::clear_has_audioprefabname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioEvent_Audio::clear_audioprefabname() {
  if (audioprefabname_ != &::google::protobuf::internal::kEmptyString) {
    audioprefabname_->clear();
  }
  clear_has_audioprefabname();
}
inline const ::std::string& AudioEvent_Audio::audioprefabname() const {
  return *audioprefabname_;
}
inline void AudioEvent_Audio::set_audioprefabname(const ::std::string& value) {
  set_has_audioprefabname();
  if (audioprefabname_ == &::google::protobuf::internal::kEmptyString) {
    audioprefabname_ = new ::std::string;
  }
  audioprefabname_->assign(value);
}
inline void AudioEvent_Audio::set_audioprefabname(const char* value) {
  set_has_audioprefabname();
  if (audioprefabname_ == &::google::protobuf::internal::kEmptyString) {
    audioprefabname_ = new ::std::string;
  }
  audioprefabname_->assign(value);
}
inline void AudioEvent_Audio::set_audioprefabname(const char* value, size_t size) {
  set_has_audioprefabname();
  if (audioprefabname_ == &::google::protobuf::internal::kEmptyString) {
    audioprefabname_ = new ::std::string;
  }
  audioprefabname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioEvent_Audio::mutable_audioprefabname() {
  set_has_audioprefabname();
  if (audioprefabname_ == &::google::protobuf::internal::kEmptyString) {
    audioprefabname_ = new ::std::string;
  }
  return audioprefabname_;
}
inline ::std::string* AudioEvent_Audio::release_audioprefabname() {
  clear_has_audioprefabname();
  if (audioprefabname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = audioprefabname_;
    audioprefabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioEvent_Audio::set_allocated_audioprefabname(::std::string* audioprefabname) {
  if (audioprefabname_ != &::google::protobuf::internal::kEmptyString) {
    delete audioprefabname_;
  }
  if (audioprefabname) {
    set_has_audioprefabname();
    audioprefabname_ = audioprefabname;
  } else {
    clear_has_audioprefabname();
    audioprefabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AudioEvent

// repeated .NFFS.AudioEvent.Audio audioList = 1;
inline int AudioEvent::audiolist_size() const {
  return audiolist_.size();
}
inline void AudioEvent::clear_audiolist() {
  audiolist_.Clear();
}
inline const ::NFFS::AudioEvent_Audio& AudioEvent::audiolist(int index) const {
  return audiolist_.Get(index);
}
inline ::NFFS::AudioEvent_Audio* AudioEvent::mutable_audiolist(int index) {
  return audiolist_.Mutable(index);
}
inline ::NFFS::AudioEvent_Audio* AudioEvent::add_audiolist() {
  return audiolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::AudioEvent_Audio >&
AudioEvent::audiolist() const {
  return audiolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::AudioEvent_Audio >*
AudioEvent::mutable_audiolist() {
  return &audiolist_;
}

// -------------------------------------------------------------------

// MoveEvent_Move

// required float eventTime = 1;
inline bool MoveEvent_Move::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveEvent_Move::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveEvent_Move::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveEvent_Move::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float MoveEvent_Move::eventtime() const {
  return eventtime_;
}
inline void MoveEvent_Move::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.MoveEvent.METype eventType = 2;
inline bool MoveEvent_Move::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveEvent_Move::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveEvent_Move::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveEvent_Move::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::MoveEvent_METype MoveEvent_Move::eventtype() const {
  return static_cast< ::NFFS::MoveEvent_METype >(eventtype_);
}
inline void MoveEvent_Move::set_eventtype(::NFFS::MoveEvent_METype value) {
  assert(::NFFS::MoveEvent_METype_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required float moveDis = 3;
inline bool MoveEvent_Move::has_movedis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveEvent_Move::set_has_movedis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveEvent_Move::clear_has_movedis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveEvent_Move::clear_movedis() {
  movedis_ = 0;
  clear_has_movedis();
}
inline float MoveEvent_Move::movedis() const {
  return movedis_;
}
inline void MoveEvent_Move::set_movedis(float value) {
  set_has_movedis();
  movedis_ = value;
}

// required float moveTime = 4;
inline bool MoveEvent_Move::has_movetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveEvent_Move::set_has_movetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveEvent_Move::clear_has_movetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveEvent_Move::clear_movetime() {
  movetime_ = 0;
  clear_has_movetime();
}
inline float MoveEvent_Move::movetime() const {
  return movetime_;
}
inline void MoveEvent_Move::set_movetime(float value) {
  set_has_movetime();
  movetime_ = value;
}

// -------------------------------------------------------------------

// MoveEvent

// repeated .NFFS.MoveEvent.Move moveEvent = 1;
inline int MoveEvent::moveevent_size() const {
  return moveevent_.size();
}
inline void MoveEvent::clear_moveevent() {
  moveevent_.Clear();
}
inline const ::NFFS::MoveEvent_Move& MoveEvent::moveevent(int index) const {
  return moveevent_.Get(index);
}
inline ::NFFS::MoveEvent_Move* MoveEvent::mutable_moveevent(int index) {
  return moveevent_.Mutable(index);
}
inline ::NFFS::MoveEvent_Move* MoveEvent::add_moveevent() {
  return moveevent_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::MoveEvent_Move >&
MoveEvent::moveevent() const {
  return moveevent_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::MoveEvent_Move >*
MoveEvent::mutable_moveevent() {
  return &moveevent_;
}

// -------------------------------------------------------------------

// CameraEvent_Camera

// required float eventTime = 1;
inline bool CameraEvent_Camera::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraEvent_Camera::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraEvent_Camera::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraEvent_Camera::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float CameraEvent_Camera::eventtime() const {
  return eventtime_;
}
inline void CameraEvent_Camera::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.CameraEvent.CEType eventType = 2;
inline bool CameraEvent_Camera::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraEvent_Camera::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraEvent_Camera::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraEvent_Camera::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::CameraEvent_CEType CameraEvent_Camera::eventtype() const {
  return static_cast< ::NFFS::CameraEvent_CEType >(eventtype_);
}
inline void CameraEvent_Camera::set_eventtype(::NFFS::CameraEvent_CEType value) {
  assert(::NFFS::CameraEvent_CEType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required .NFFS.FSVector3 amountParam = 3;
inline bool CameraEvent_Camera::has_amountparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraEvent_Camera::set_has_amountparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraEvent_Camera::clear_has_amountparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraEvent_Camera::clear_amountparam() {
  if (amountparam_ != NULL) amountparam_->::NFFS::FSVector3::Clear();
  clear_has_amountparam();
}
inline const ::NFFS::FSVector3& CameraEvent_Camera::amountparam() const {
  return amountparam_ != NULL ? *amountparam_ : *default_instance_->amountparam_;
}
inline ::NFFS::FSVector3* CameraEvent_Camera::mutable_amountparam() {
  set_has_amountparam();
  if (amountparam_ == NULL) amountparam_ = new ::NFFS::FSVector3;
  return amountparam_;
}
inline ::NFFS::FSVector3* CameraEvent_Camera::release_amountparam() {
  clear_has_amountparam();
  ::NFFS::FSVector3* temp = amountparam_;
  amountparam_ = NULL;
  return temp;
}
inline void CameraEvent_Camera::set_allocated_amountparam(::NFFS::FSVector3* amountparam) {
  delete amountparam_;
  amountparam_ = amountparam;
  if (amountparam) {
    set_has_amountparam();
  } else {
    clear_has_amountparam();
  }
}

// required float shakeTime = 4;
inline bool CameraEvent_Camera::has_shaketime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraEvent_Camera::set_has_shaketime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraEvent_Camera::clear_has_shaketime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraEvent_Camera::clear_shaketime() {
  shaketime_ = 0;
  clear_has_shaketime();
}
inline float CameraEvent_Camera::shaketime() const {
  return shaketime_;
}
inline void CameraEvent_Camera::set_shaketime(float value) {
  set_has_shaketime();
  shaketime_ = value;
}

// -------------------------------------------------------------------

// CameraEvent

// repeated .NFFS.CameraEvent.Camera cameraEventList = 1;
inline int CameraEvent::cameraeventlist_size() const {
  return cameraeventlist_.size();
}
inline void CameraEvent::clear_cameraeventlist() {
  cameraeventlist_.Clear();
}
inline const ::NFFS::CameraEvent_Camera& CameraEvent::cameraeventlist(int index) const {
  return cameraeventlist_.Get(index);
}
inline ::NFFS::CameraEvent_Camera* CameraEvent::mutable_cameraeventlist(int index) {
  return cameraeventlist_.Mutable(index);
}
inline ::NFFS::CameraEvent_Camera* CameraEvent::add_cameraeventlist() {
  return cameraeventlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::CameraEvent_Camera >&
CameraEvent::cameraeventlist() const {
  return cameraeventlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::CameraEvent_Camera >*
CameraEvent::mutable_cameraeventlist() {
  return &cameraeventlist_;
}

// -------------------------------------------------------------------

// EnableEvents_Enable

// required float eventTime = 1;
inline bool EnableEvents_Enable::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnableEvents_Enable::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnableEvents_Enable::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnableEvents_Enable::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float EnableEvents_Enable::eventtime() const {
  return eventtime_;
}
inline void EnableEvents_Enable::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.EnableEvents.EEETYPE eventType = 2;
inline bool EnableEvents_Enable::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnableEvents_Enable::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnableEvents_Enable::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnableEvents_Enable::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::EnableEvents_EEETYPE EnableEvents_Enable::eventtype() const {
  return static_cast< ::NFFS::EnableEvents_EEETYPE >(eventtype_);
}
inline void EnableEvents_Enable::set_eventtype(::NFFS::EnableEvents_EEETYPE value) {
  assert(::NFFS::EnableEvents_EEETYPE_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required string targetName = 3;
inline bool EnableEvents_Enable::has_targetname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnableEvents_Enable::set_has_targetname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnableEvents_Enable::clear_has_targetname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnableEvents_Enable::clear_targetname() {
  if (targetname_ != &::google::protobuf::internal::kEmptyString) {
    targetname_->clear();
  }
  clear_has_targetname();
}
inline const ::std::string& EnableEvents_Enable::targetname() const {
  return *targetname_;
}
inline void EnableEvents_Enable::set_targetname(const ::std::string& value) {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  targetname_->assign(value);
}
inline void EnableEvents_Enable::set_targetname(const char* value) {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  targetname_->assign(value);
}
inline void EnableEvents_Enable::set_targetname(const char* value, size_t size) {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  targetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnableEvents_Enable::mutable_targetname() {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  return targetname_;
}
inline ::std::string* EnableEvents_Enable::release_targetname() {
  clear_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetname_;
    targetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnableEvents_Enable::set_allocated_targetname(::std::string* targetname) {
  if (targetname_ != &::google::protobuf::internal::kEmptyString) {
    delete targetname_;
  }
  if (targetname) {
    set_has_targetname();
    targetname_ = targetname;
  } else {
    clear_has_targetname();
    targetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EnableEvents

// repeated .NFFS.EnableEvents.Enable enableList = 1;
inline int EnableEvents::enablelist_size() const {
  return enablelist_.size();
}
inline void EnableEvents::clear_enablelist() {
  enablelist_.Clear();
}
inline const ::NFFS::EnableEvents_Enable& EnableEvents::enablelist(int index) const {
  return enablelist_.Get(index);
}
inline ::NFFS::EnableEvents_Enable* EnableEvents::mutable_enablelist(int index) {
  return enablelist_.Mutable(index);
}
inline ::NFFS::EnableEvents_Enable* EnableEvents::add_enablelist() {
  return enablelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable >&
EnableEvents::enablelist() const {
  return enablelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable >*
EnableEvents::mutable_enablelist() {
  return &enablelist_;
}

// -------------------------------------------------------------------

// GlobalSpeed_Speed

// required float eventTime = 1;
inline bool GlobalSpeed_Speed::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalSpeed_Speed::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalSpeed_Speed::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalSpeed_Speed::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float GlobalSpeed_Speed::eventtime() const {
  return eventtime_;
}
inline void GlobalSpeed_Speed::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.GlobalSpeed.EGSTYPE eventType = 2;
inline bool GlobalSpeed_Speed::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalSpeed_Speed::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalSpeed_Speed::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalSpeed_Speed::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::GlobalSpeed_EGSTYPE GlobalSpeed_Speed::eventtype() const {
  return static_cast< ::NFFS::GlobalSpeed_EGSTYPE >(eventtype_);
}
inline void GlobalSpeed_Speed::set_eventtype(::NFFS::GlobalSpeed_EGSTYPE value) {
  assert(::NFFS::GlobalSpeed_EGSTYPE_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required float speedValue = 3;
inline bool GlobalSpeed_Speed::has_speedvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GlobalSpeed_Speed::set_has_speedvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GlobalSpeed_Speed::clear_has_speedvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GlobalSpeed_Speed::clear_speedvalue() {
  speedvalue_ = 0;
  clear_has_speedvalue();
}
inline float GlobalSpeed_Speed::speedvalue() const {
  return speedvalue_;
}
inline void GlobalSpeed_Speed::set_speedvalue(float value) {
  set_has_speedvalue();
  speedvalue_ = value;
}

// -------------------------------------------------------------------

// GlobalSpeed

// repeated .NFFS.GlobalSpeed.Speed speedList = 1;
inline int GlobalSpeed::speedlist_size() const {
  return speedlist_.size();
}
inline void GlobalSpeed::clear_speedlist() {
  speedlist_.Clear();
}
inline const ::NFFS::GlobalSpeed_Speed& GlobalSpeed::speedlist(int index) const {
  return speedlist_.Get(index);
}
inline ::NFFS::GlobalSpeed_Speed* GlobalSpeed::mutable_speedlist(int index) {
  return speedlist_.Mutable(index);
}
inline ::NFFS::GlobalSpeed_Speed* GlobalSpeed::add_speedlist() {
  return speedlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::GlobalSpeed_Speed >&
GlobalSpeed::speedlist() const {
  return speedlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::GlobalSpeed_Speed >*
GlobalSpeed::mutable_speedlist() {
  return &speedlist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace NFFS

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::BulletEvent_EBEType>() {
  return ::NFFS::BulletEvent_EBEType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::BulletEvent_EBE_BACKType>() {
  return ::NFFS::BulletEvent_EBE_BACKType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::MoveEvent_METype>() {
  return ::NFFS::MoveEvent_METype_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::CameraEvent_CEType>() {
  return ::NFFS::CameraEvent_CEType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::EnableEvents_EEETYPE>() {
  return ::NFFS::EnableEvents_EEETYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::GlobalSpeed_EGSTYPE>() {
  return ::NFFS::GlobalSpeed_EGSTYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NFFleetingDefine_2eproto__INCLUDED
